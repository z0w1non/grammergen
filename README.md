# Grammergen

## 文法規則の自動生成
遺伝的プログラミングを利用して以下のようなS式で表現可能な文法規則の生成を試みます。
```
(| (? (+ (? (| (| (| (? (| (| (?)) "="))) (+ (| (| (? (| (?)))) (? (| (+ (|)) (?)))) (?))) "+")) (| (? (| " " (| (| (| "w" (? (?))) (| (| (| (| (? (+ (+ (| (| (+ (? "T") (| (? "I") (? (+)))) (+ "2" (+ "/" "t"))) (? (? (| (? ")") (| "1" (? (? (| (+ (? "u") ".") "7")))))))) (? (? """))) (| (+ (| (| (? (| (? (+ (+ (+) "9") (| (+ (?)) (+)))) "o")) "T") (? "Y")) "Z") (? (| (+ (+ (? "Z")) (?)) (+ (? (| (| (| (? (| (| (?)) "="))) (+ (| (| (? (| (?)))) (? (| (+ (|)) (?)))) (?))) "+")) (| (? (| " " (| (| (| "w" (? (?))) (| (| (| (| (? (+ (+ (| (| (+ (? (| (+ (| (+ (+ (| (|) (+)) (|)) (+ (| (?) "D") (+))) (| (| "`" "g") (| (?) (?)))) (? (? (+ "z" "=")))) (+ "3"))) (| (? "I") (? (+)))) (+ "2" (+ "/" "t"))) (? (? (| (? ")") (| "1" (? (? (| (+ (| (| (? (| (? (+ (+ (+) "9") (| (+ (?)) (+)))) "o")) "T") (? "Y")) "Z") (? (| (+ (+ (? "Z")) (?)) (+ (? (| (| (| (? (| (| (?)) "="))) (+ (| (| (? (| (?)))) (? (| (+ (|)) (?)))) (?))) "+")) (| (? (| " " (| (| (| "w" (? (?))) (| (| (| (| (? (+ (+ (| (| (+ (? (| (+ (| (+ (+ (| (|) (+)) (|)) (+ (| (?) "D") (+))) (| (| "`" "g") (| (?) (?)))) (? (? (+ "z" "=")))) (+ "3"))) (| (? "I") (? (+)))) (+ "2" (+ "/" "t"))) (? (? (| (? ")") (| "1" (? (? (| (+ (? "u") ".") "7")))))))) (? (? """))) (| (+ (| (| (? (| (? (+ (+ (+) "9") (| (+ (?)) (+)))) "o")) "T") (? "Y")) "Z") (? (| (+ (+ (?)) (?)) (| (| "t") "g")))))) (? "-")) (? (? (+ "z" "=")))) (? (+ "T" (+ (| (+ (|)) "M") (+ "8" (? (+))))))) (? (? (?))))) "8"))) (+ (? (? (+ (| (?)) "M"))) (? (? (| (+ "]" "1") "/")))))))))))))))) (? (? """))) (| (+ (| (| (? (| (? (+ (+ (+) "9") (| (+ (?)) (+)))) "o")) "T") (? "Y")) "Z") (? (| (+ (+ (?)) (?)) (| (| "t") "g")))))) (? "-")) (? (? (+ "z" "=")))) (? (+ "T" (+ (| (+ (|)) "M") (+ "8" (? (+))))))) (? (? (?))))) "8"))) (+ (? (? (+ (| (?)) "M"))) (? (? (| (+ "]" "1") "/"))))))))))) (? "-")) (? (? (+ "z" "=")))) (? (+ "T" (+ (| (+ (|)) "M") (+ "8" (? (+))))))) (? (? (?))))) "8"))) (+ (? (? (+ (| (?)) "M"))) (? (? (| "<" "/"))))))) (?))
```

## 着想
英語や日本語のような自然言語の文法は規則は、人間によって解析され体系化されています。例として、誰でも端末にひらがなを入力しスペースキーを押下すれば、ただそれだけでひらがなを漢字に変換することができます。背景にはIME(Input Method Editor)の存在があり、これらは内部に対象言語の文法や、単語の品詞等の情報を保持しています。それらに基づき、IMEは入力された変換前の文字列を形態素（言語の最小単位）の集合体に分割します。英語等の他言語と異なり、日本語には英語におけるスペースのような単語を区切るために一般的に使われる文字が存在しません。どのような形態素から構成されているかを探るための基礎的な分割単位のヒントとなり得る情報が、日本語には存在しないと言えます。現実にはこの文書を読んでいる貴方のように日本語を理解し得る人間がいるため、IMEを支える言語的な学問や技術は保守され続けます。例え言語に新しい単語が追加されたり、あるいは新しい文法が追加されたりしたとしても、技術者や学者はそれをすぐに体系化し、自分達が扱う道具や構造の中に取り込むでしょう。言語学を専攻していない一般的な人間も、その全てを明文化し構造的に説明できないとしても、ある文がその言語的に許容される正しいものかどうかは分かるものです。言語の文法規則は生活の至る所に浸透していて、人間はそれをいつでも扱うことができますが、コンピュータはどうでしょう。先に挙げたIMEはコンピュータが文法規則を扱っている例とも言えます。しかしコンピュータが扱う文法規則そのものは依然として人間によって体系化されています。現実として、現在存在するコンピュータが自発的にそれを解析し、それをできる限り説明できるような文法規則をその場で作り上げることは、残念ながらできません。少なくとも一般的ではありません。同じ名前で括られる特定の地域に付属するどのような言語も、1000年前と同じ形をしていないでしょう。今から1000年後の言語に適した文法規則は1000年後の人間によって作られるでしょうか。どうにかしてコンピュータに自発的に文法規則を求めさせることはできないでしょうか。人が言語を研究し体系化する際、人が脳の中で行っている解析処理を、目の前にあるコンピュータに搭載されたメモリやCPUの中で行えないものでしょうか。このリポジトリでは遺伝的プログラミングを利用して木構造で任意の言語の文法規則を構造化して表現することを試みます。

## 基本的な構造
|式|説明|
|---|---|
|"str"|文字列 str そのものを表現します。|
|&#x007C; a b|a または b を表現します。|
|+ a b|a の後に b を連結した文を表現します。|
|? a|a がある、あるいはない文を表現します。|
基本的にポーランド記法（前置記法）を採用しています。最初に処理の名前があり、それに続いて処理の対象があります。この記法を採用している最たる理由は、演算の解決順序が明瞭であり、木構造の解析ロジックが簡潔になるということに尽きます。汎用的に任意の自然言語を説明できるような文法規則は、それ自身が汎用的な規則によって構築されるべきでしょう。

## パラメータ設定
### generic_programming Class
|メンバ関数宣言|説明|
|---|---|
|`generic_programming()`|デフォルトコンストラクタ|
|`void read_input(std::string_view file_name)`|テキストファイルに含まれる各行を、文法規則を適応させる文字列として読み込みます。|
|`void set_elite_ratio(double elite_ratio)`|次世代にそのまま移送されるエリートの割合を設定します。|
|`void set_mutation_ratio(double elite_ratio)`|突然変異が発生する確率を指定します。|
|`void set_max_unmodified_count(std::size_t max_unmodified_count)`|個体の評価値の最大値に変更がない反復を、最大何回まで許容するか設定します。|
|`void run()`|遺伝的プログラミングを開始します。|

## 現状
この試みは現在進行中です。`g++ main.cpp std=c++17` というコンパイラによって解析される言語によって、少なくとも実行可能ファイルを生成することはできるでしょうが、それ以上の意味、実際に有意で実用的な文法規則を生成するには至っていません。今後、後述する課題を解決し、無作為に見える構造の中から求めている宝を発掘できることを祈ります。

## 課題
