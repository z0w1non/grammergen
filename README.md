# Grammergen

## 文法規則の自動生成
遺伝的プログラミングを利用して以下のようなS式で表現可能な文法規則の生成を試みます。
```
(| (? (+ (? (| (| (| (? (| (| (?)) "="))) (+ (| (| (? (| (?)))) (? (| (+ (|)) (?)))) (?))) "+")) (| (? (| " " (| (| (| "w" (? (?))) (| (| (| (| (? (+ (+ (| (| (+ (? "T") (| (? "I") (? (+)))) (+ "2" (+ "/" "t"))) (? (? (| (? ")") (| "1" (? (? (| (+ (? "u") ".") "7")))))))) (? (? """))) (| (+ (| (| (? (| (? (+ (+ (+) "9") (| (+ (?)) (+)))) "o")) "T") (? "Y")) "Z") (? (| (+ (+ (? "Z")) (?)) (+ (? (| (| (| (? (| (| (?)) "="))) (+ (| (| (? (| (?)))) (? (| (+ (|)) (?)))) (?))) "+")) (| (? (| " " (| (| (| "w" (? (?))) (| (| (| (| (? (+ (+ (| (| (+ (? (| (+ (| (+ (+ (| (|) (+)) (|)) (+ (| (?) "D") (+))) (| (| "`" "g") (| (?) (?)))) (? (? (+ "z" "=")))) (+ "3"))) (| (? "I") (? (+)))) (+ "2" (+ "/" "t"))) (? (? (| (? ")") (| "1" (? (? (| (+ (| (| (? (| (? (+ (+ (+) "9") (| (+ (?)) (+)))) "o")) "T") (? "Y")) "Z") (? (| (+ (+ (? "Z")) (?)) (+ (? (| (| (| (? (| (| (?)) "="))) (+ (| (| (? (| (?)))) (? (| (+ (|)) (?)))) (?))) "+")) (| (? (| " " (| (| (| "w" (? (?))) (| (| (| (| (? (+ (+ (| (| (+ (? (| (+ (| (+ (+ (| (|) (+)) (|)) (+ (| (?) "D") (+))) (| (| "`" "g") (| (?) (?)))) (? (? (+ "z" "=")))) (+ "3"))) (| (? "I") (? (+)))) (+ "2" (+ "/" "t"))) (? (? (| (? ")") (| "1" (? (? (| (+ (? "u") ".") "7")))))))) (? (? """))) (| (+ (| (| (? (| (? (+ (+ (+) "9") (| (+ (?)) (+)))) "o")) "T") (? "Y")) "Z") (? (| (+ (+ (?)) (?)) (| (| "t") "g")))))) (? "-")) (? (? (+ "z" "=")))) (? (+ "T" (+ (| (+ (|)) "M") (+ "8" (? (+))))))) (? (? (?))))) "8"))) (+ (? (? (+ (| (?)) "M"))) (? (? (| (+ "]" "1") "/")))))))))))))))) (? (? """))) (| (+ (| (| (? (| (? (+ (+ (+) "9") (| (+ (?)) (+)))) "o")) "T") (? "Y")) "Z") (? (| (+ (+ (?)) (?)) (| (| "t") "g")))))) (? "-")) (? (? (+ "z" "=")))) (? (+ "T" (+ (| (+ (|)) "M") (+ "8" (? (+))))))) (? (? (?))))) "8"))) (+ (? (? (+ (| (?)) "M"))) (? (? (| (+ "]" "1") "/"))))))))))) (? "-")) (? (? (+ "z" "=")))) (? (+ "T" (+ (| (+ (|)) "M") (+ "8" (? (+))))))) (? (? (?))))) "8"))) (+ (? (? (+ (| (?)) "M"))) (? (? (| "<" "/"))))))) (?))
```

## 着想
英語や日本語のような自然言語の文法は規則は、人間によって解析され体系化されています。例として、誰でも端末にひらがなを入力しスペースキーを押下すれば、ただそれだけでひらがなを漢字に変換することができます。背景にはIME(Input Method Editor)の存在があり、これらは内部に対象言語の文法や、単語の品詞等の情報を保持しています。それらに基づき、IMEは入力された変換前の文字列を形態素（言語の最小単位）の集合体に分割します。英語等の他言語と異なり、日本語には英語におけるスペースのような単語を区切るために一般的に使われる文字が存在しません。どのような形態素から構成されているかを探るための基礎的な分割単位のヒントとなり得る情報が、日本語には存在しないと言えます。現実にはこの文書を読んでいる貴方のように日本語を理解し得る人間がいるため、IMEを支える言語的な学問や技術は保守され続けます。例え言語に新しい単語が追加されたり、あるいは新しい文法が追加されたりしたとしても、技術者や学者はそれをすぐに体系化し、自分達が扱う道具や構造の中に取り込むでしょう。言語学を専攻していない一般的な人間も、その全てを明文化し構造的に説明できないとしても、ある文がその言語的に許容される正しいものかどうかは分かるものです。言語の文法規則は生活の至る所に浸透していて、人間はそれをいつでも扱うことができますが、コンピュータはどうでしょう。先に挙げたIMEはコンピュータが文法規則を扱っている例とも言えます。しかしコンピュータが扱う文法規則そのものは依然として人間によって体系化されています。現実として、現在存在するコンピュータが自発的にそれを解析し、それをできる限り説明できるような文法規則をその場で作り上げることは、残念ながらできません。少なくとも一般的ではありません。同じ名前で括られる特定の地域に付属するどのような言語も、1000年前と同じ形をしていないでしょう。今から1000年後の言語に適した文法規則は1000年後の人間によって作られるでしょうか。どうにかしてコンピュータに自発的に文法規則を求めさせることはできないでしょうか。人が言語を研究し体系化する際、人が脳の中で行っている解析処理を、目の前にあるコンピュータに搭載されたメモリやCPUの中で行えないものでしょうか。このリポジトリでは遺伝的プログラミングを利用して木構造で任意の言語の文法規則を構造化して表現することを試みます。

## 基本的な文法規則

|式|説明|
|---|---|
|"str"|文字列 str そのものを表現します。|
|&#x007C; a b|a または b を表現します。|
|+ a b|a の後に b を連結した文を表現します。|
|? a|a がある、あるいはない文を表現します。|


### ポーランド記法
文法規則を表現するためにポーランド記法（前置記法）を採用しています。最初に処理の名前があり、それに続いて処理の対象があります。この記法を採用している最たる理由は、演算の解決順序が明瞭であり、木構造の解析ロジックが簡潔になるということに尽きます。汎用的に任意の自然言語を説明できるような文法規則は、それ自身が汎用的な規則によって構築されるべきでしょう。標準的な数学の体系においては乗算は加算より優先して解決されますが、それは数式という言語が扱う問題に適応し、多くの場合においてより簡潔に表現できるように規則を複雑化させていることに起因します。一方このリポジトリでは規則に数式のような複雑性を持ち込みません。目の前の問題に対して最適化された構文は目の前の問題を解消しますが、後に他の規則との整合性や優先順位といった複雑性を生み、それ自身に対する理解を求めます。それを避けるため、ここではポーランド記法の採用に留まらず、糖衣構文やエイリアスといった冗長性のある概念を極力排除した規則によって文法規則を扱います。

## パラメータ設定
遺伝的プログラミングはアルゴリズムの性質上、いくつかのパラメータを事前に設定することを求めます。パラメータは最終的に得られる解の質や、収束にかかる反復数および実行時間に直結するため、扱っている言語に合わせて調整できるようにするため下記に記載するいくつかのミューテータを提供しています。
### generic_programming Class

|メンバ関数宣言|説明|
|---|---|
|`generic_programming()`|デフォルトコンストラクタ|
|`void read_input(std::string_view file_name)`|テキストファイルに含まれる各行を、文法規則を適応させる文字列として読み込みます。|
|`void set_elite_ratio(double elite_ratio)`|次世代にそのまま移送されるエリートの割合を設定します。[0 - 1.0] の任意の値を設定することができます。エリートとは個体中の評価値が高かった上位n個の文法規則を指します。ここで指定された率と個体の総数を乗じた値を整数単位に切り捨て、具体的なエリートの数を算出します。一定数のエリートを移送する遺伝的プログラミングは、各反復時点における候補解の評価値の最大が保証されるという利点を持ちますが、一方でエリートが常に候補解の中に残るため、候補解全体から多様性が失われ局所的最適解に陥る要因になり得ます。|
|`void set_mutation_ratio(double elite_ratio)`|突然変異が発生する確率を指定します。突然変異は個体を構成する全てのノードから無作為に選択されたひとつのノードを、新しく無作為に生成したノードに入れ替えることによって実装されます。選択されたノードの子のノードは最初の状態と同様に再接続されます。突然変異の前後で個体を構成するノード数は変動しません。|
|`void set_max_unmodified_count(std::size_t max_unmodified_count)`|個体の評価値の最大値に変更がない反復を、最大何回まで許容するか設定します。アルゴリズムは各反復時点の暫定最適解の評価値を保存し、それらの変動がなくなってからここで設定した回数だけ反復した後、探索を終了します。|
|`void run()`|遺伝的プログラミングを開始します。|

## 現状
この試みは現在進行中です。`g++ main.cpp std=c++17` というコンパイラによって解析される言語によって、少なくとも実行可能ファイルを生成することはできるでしょうが、それ以上の意味、実際に有意で実用的な文法規則を生成するには残念ながら至っていません。今後、後述する課題を解決し、無作為に見える構造の中から求めている宝を発掘できることを祈ります。

## 課題
- 交叉に伴うときとして不必要な木構造の複雑化について評価値を減点する仕組みがない。また、単にそのような仕組みを採用すると、与えられた入力文字列を完全にパースできる文法規則が生成されるより前に、文法規則の構造を最小化することで適応度を上げる個体で候補解が埋め尽くされる。複雑性の程度に比例して木構造の評価にかかる時間的コストが増大する。
- 究極的に汎用的な文法は有意な文法ではない。極端な例として「任意の文字が任意の回数繰り返される」という文法は確かにあらゆる入力文字列をパースできるが、同時に本来扱っている言語に含まれない文を表現系に内包している。ここで求められている文法はできるだけ具体的であり、ある文脈において出現しうる語群をできるだけ過不足なく知っている構造である。
